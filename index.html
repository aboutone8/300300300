<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="csrf-token" content="">
    <!-- 修改CSP以允许Solana钱包API和外部脚本 -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://cdn.jsdelivr.net https://unpkg.com 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src https://* wss://*;">
    <title>官方游戏平台</title>
    <!-- 加载Solana Web3.js -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <!-- 加载SPL Token -->
    <script src="https://unpkg.com/@solana/spl-token@latest/lib/index.iife.min.js"></script>
    <style>
        :root {
            --primary-color: #4CAF50;
            --primary-hover: #45a049;
            --accent-color: #9945FF;
            --danger-color: #f44336;
            --warning-color: #ff9800;
            --banner-bg: #d32f2f;
            --banner-text: #ffeb3b;
            --text-light: #ffffff;
            --text-dark: #333333;
            --bg-light: #f5f5f5;
            --overlay-bg: rgba(0, 0, 0, 0.85);
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        html, body {
            height: 100%;
            font-family: 'PingFang SC', 'Microsoft YaHei', Arial, sans-serif;
            background-color: var(--bg-light);
            color: var(--text-dark);
            overflow-x: hidden;
        }
        
        /* 横幅样式 */
        .banner {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: var(--banner-bg);
            color: var(--banner-text);
            font-weight: bold;
            padding: 10px 20px;
            text-align: center;
            z-index: 9999;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            font-size: 0.9rem;
            transition: transform 0.3s;
        }
        
        .banner-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: transparent;
            border: none;
            color: var(--banner-text);
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 10000;
        }
        
        .banner-collapsed {
            transform: translateY(-100%);
        }
        
        .banner-info {
            margin: 5px 0;
        }
        
        .banner-wallet {
            font-family: monospace;
            background: rgba(255,255,255,0.2);
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
            margin-top: 5px;
        }
        
        /* 支付相关样式 */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--overlay-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .payment-box {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
            max-width: 90%;
            width: 450px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        }
        
        .payment-title {
            margin-bottom: 1.5rem;
            font-size: 1.5rem;
            color: var(--text-dark);
        }
        
        .payment-button {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.2rem;
            border-radius: 5px;
            cursor: pointer;
            margin: 1rem 0;
            transition: background-color 0.2s, transform 0.1s;
        }
        
        .payment-button:hover {
            filter: brightness(1.1);
        }
        
        .payment-button:active {
            transform: scale(0.98);
        }
        
        .connect-wallet-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 1rem;
        }
        
        .wallet-status {
            margin: 10px 0;
            font-size: 0.9rem;
            color: #666;
        }
        
        .wallet-address {
            font-family: monospace;
            word-break: break-all;
            background: #f5f5f5;
            padding: 5px;
            border-radius: 4px;
            margin: 5px 0;
            font-size: 0.8rem;
        }
        
        /* 提醒消息 */
        .alert-message {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            z-index: 10001;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
        }
        
        .alert-success {
            background-color: var(--primary-color);
        }
        
        .alert-error {
            background-color: var(--danger-color);
        }
        
        .alert-warning {
            background-color: var(--warning-color);
            color: #333;
        }
        
        /* 加载指示器 */
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid var(--accent-color);
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
            display: none;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* 复制按钮 */
        .copy-btn {
            background: #e0e0e0;
            border: none;
            padding: 4px 8px;
            margin-left: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.8rem;
        }
        
        .copy-btn:hover {
            background: #d0d0d0;
        }
        
        /* 游戏选择器 */
        .game-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            max-width: 800px;
            margin: 30px auto;
            padding: 20px;
        }
        
        .game-option {
            background: white;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .game-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        
        .game-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--accent-color);
        }
        
        .game-title {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: var(--text-dark);
        }
        
        .game-description {
            font-size: 0.9rem;
            color: #666;
        }
        
        /* 容器 */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .game-container {
            margin-top: 70px;
            text-align: center;
            position: relative;
        }
        
        /* 按钮样式 */
        .action-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .action-btn:hover {
            background-color: var(--primary-hover);
        }
        
        /* 效果样式 */
        .hidden {
            display: none !important;
        }
        
        /* 响应式调整 */
        @media (max-width: 768px) {
            .game-selector {
                grid-template-columns: 1fr;
            }
            
            .payment-box {
                width: 90%;
                padding: 1.5rem;
            }
            
            .game-title {
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <!-- 官方声明横幅 -->
    <div id="officialBanner" class="banner">
        <div class="banner-info">官方声明：本游戏仅供娱乐，请理性游戏。</div>
        <div>官方钱包地址: <span class="banner-wallet">YOUR_SOLANA_WALLET_ADDRESS</span>
            <button class="copy-btn" onclick="copyWalletAddress()">复制</button>
        </div>
    </div>
    <button id="bannerToggle" class="banner-toggle">▲</button>
    
    <!-- 弹出消息容器 -->
    <div id="alertContainer" class="alert-message"></div>
    
    <!-- 支付界面 -->
    <div id="paymentOverlay" class="overlay">
        <div class="payment-box">
            <h2 class="payment-title">开始游戏</h2>
            <p>请付费1枚USDC开始游戏</p>
            
            <div id="walletSection">
                <button id="connectWalletBtn" class="connect-wallet-btn">连接钱包</button>
                <div id="walletStatus" class="wallet-status">未连接钱包</div>
                <div id="walletAddress" class="wallet-address hidden"></div>
            </div>
            
            <div id="paymentActions" class="hidden">
                <button id="payButton" class="payment-button">支付1 USDC</button>
                <div id="loader" class="loader"></div>
                <p id="paymentNotice">请确保您的钱包中有足够的USDC，并已授权此应用使用您的钱包。</p>
            </div>
        </div>
    </div>
    
    <!-- 游戏选择界面 -->
    <div id="gameSelectorContainer" class="container game-container hidden">
        <h1>选择一个游戏</h1>
        <div class="game-selector">
            <div id="planeGameOption" class="game-option">
                <div class="game-icon">✈️</div>
                <h3 class="game-title">飞机大战</h3>
                <p class="game-description">控制您的飞机，击落敌机获取高分！</p>
            </div>
            <div id="marbleGameOption" class="game-option">
                <div class="game-icon">🔮</div>
                <h3 class="game-title">弹珠游戏</h3>
                <p class="game-description">发射弹珠，穿过障碍物到达目标！</p>
            </div>
        </div>
    </div>
    
    <!-- 飞机游戏容器 -->
    <div id="planeGameContainer" class="game-container hidden">
        <canvas id="planeCanvas"></canvas>
        <div class="control-panel">
            <button class="control-btn" id="leftBtn">←</button>
            <button class="control-btn" id="shootBtn">🔫</button>
            <button class="control-btn" id="rightBtn">→</button>
        </div>
        <button id="backToSelector" class="action-btn">返回选择</button>
    </div>
    
    <!-- 弹珠游戏容器 -->
    <div id="marbleGameContainer" class="game-container hidden">
        <canvas id="marbleCanvas"></canvas>
        <button id="backToSelectorMarble" class="action-btn">返回选择</button>
    </div>
    
    <script>
        // 常量定义
        const RECEIVER_WALLET_ADDRESS = 'YOUR_SOLANA_WALLET_ADDRESS'; // 替换为您的钱包地址
        const USDC_MINT_ADDRESS = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'; // Solana主网USDC代币地址
        
        // 工具函数
        const Helpers = {
            showMessage: function(message, type = 'success') {
                const alert = document.getElementById('alertContainer');
                alert.textContent = message;
                alert.className = `alert-message alert-${type}`;
                alert.style.display = 'block';
                
                setTimeout(() => {
                    alert.style.display = 'none';
                }, 5000);
            },
            
            showLoader: function(show) {
                document.getElementById('loader').style.display = show ? 'block' : 'none';
                if (show) {
                    document.getElementById('payButton').disabled = true;
                } else {
                    document.getElementById('payButton').disabled = false;
                }
            }
        };
        
        // 复制钱包地址
        function copyWalletAddress() {
            const walletAddress = document.querySelector('.banner-wallet').textContent;
            navigator.clipboard.writeText(walletAddress)
                .then(() => Helpers.showMessage('钱包地址已复制', 'success'))
                .catch(err => Helpers.showMessage('复制失败: ' + err.message, 'error'));
        }
        
        // 钱包连接与支付处理
        const WalletManager = {
            provider: null,
            walletConnected: false,
            connection: null,
            
            initialize: function() {
                // 检查是否有Phantom钱包插件
                if (window.solana && window.solana.isPhantom) {
                    this.provider = window.solana;
                    
                    // 连接到Solana网络
                    this.connection = new solanaWeb3.Connection(
                        solanaWeb3.clusterApiUrl('mainnet-beta'),
                        'confirmed'
                    );
                    
                    // 监听钱包连接状态变化
                    this.provider.on('connect', () => this.onConnect());
                    this.provider.on('disconnect', () => this.onDisconnect());
                    
                    // 检查是否已连接
                    if (this.provider.isConnected) {
                        this.onConnect();
                    }
                    
                    document.getElementById('connectWalletBtn').addEventListener('click', () => {
                        this.connectWallet();
                    });
                    
                    document.getElementById('payButton').addEventListener('click', () => {
                        this.makePayment();
                    });
                } else {
                    document.getElementById('walletStatus').textContent = '请安装Phantom钱包插件';
                    Helpers.showMessage('请安装Phantom钱包插件后刷新页面', 'warning');
                }
            },
            
            connectWallet: async function() {
                try {
                    Helpers.showLoader(true);
                    await this.provider.connect();
                    Helpers.showLoader(false);
                } catch (error) {
                    console.error('连接钱包错误:', error);
                    Helpers.showMessage('连接钱包失败: ' + error.message, 'error');
                    Helpers.showLoader(false);
                }
            },
            
            onConnect: function() {
                this.walletConnected = true;
                const publicKey = this.provider.publicKey.toString();
                
                document.getElementById('walletStatus').textContent = '钱包已连接';
                document.getElementById('walletAddress').textContent = publicKey;
                document.getElementById('walletAddress').classList.remove('hidden');
                document.getElementById('connectWalletBtn').textContent = '已连接';
                document.getElementById('connectWalletBtn').disabled = true;
                document.getElementById('paymentActions').classList.remove('hidden');
                
                Helpers.showMessage('钱包连接成功', 'success');
            },
            
            onDisconnect: function() {
                this.walletConnected = false;
                document.getElementById('walletStatus').textContent = '钱包已断开连接';
                document.getElementById('walletAddress').classList.add('hidden');
                document.getElementById('connectWalletBtn').textContent = '连接钱包';
                document.getElementById('connectWalletBtn').disabled = false;
                document.getElementById('paymentActions').classList.add('hidden');
                
                Helpers.showMessage('钱包已断开连接', 'warning');
            },
            
            makePayment: async function() {
                if (!this.walletConnected) {
                    Helpers.showMessage('请先连接钱包', 'warning');
                    return;
                }
                
                try {
                    Helpers.showLoader(true);
                    
                    // 获取USDC Token信息
                    const usdcMint = new solanaWeb3.PublicKey(USDC_MINT_ADDRESS);
                    const receiverWallet = new solanaWeb3.PublicKey(RECEIVER_WALLET_ADDRESS);
                    const userWallet = this.provider.publicKey;
                    
                    // 查找用户的USDC代币账户
                    const userTokenAccounts = await this.connection.getParsedTokenAccountsByOwner(
                        userWallet,
                        { mint: usdcMint }
                    );
                    
                    if (userTokenAccounts.value.length === 0) {
                        throw new Error('您的钱包中没有USDC代币账户');
                    }
                    
                    const userTokenAccount = userTokenAccounts.value[0].pubkey;
                    
                    // 查找接收者的USDC代币账户
                    const receiverTokenAccounts = await this.connection.getParsedTokenAccountsByOwner(
                        receiverWallet,
                        { mint: usdcMint }
                    );
                    
                    if (receiverTokenAccounts.value.length === 0) {
                        throw new Error('接收者钱包没有USDC代币账户');
                    }
                    
                    const receiverTokenAccount = receiverTokenAccounts.value[0].pubkey;
                    
                    // 创建转账指令
                    const transaction = new solanaWeb3.Transaction().add(
                        splToken.Token.createTransferInstruction(
                            splToken.TOKEN_PROGRAM_ID,
                            userTokenAccount,
                            receiverTokenAccount,
                            userWallet,
                            [],
                            1000000 // USDC有6位小数，1 USDC = 1000000
                        )
                    );
                    
                    // 添加最近的区块哈希
                    transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;
                    transaction.feePayer = userWallet;
                    
                    // 发送交易
                    const signed = await this.provider.signTransaction(transaction);
                    const signature = await this.connection.sendRawTransaction(signed.serialize());
                    
                    // 等待确认
                    await this.connection.confirmTransaction(signature);
                    
                    Helpers.showLoader(false);
                    Helpers.showMessage('支付成功！游戏即将开始', 'success');
                    
                    // 支付成功，显示游戏选择界面
                    setTimeout(() => {
                        document.getElementById('paymentOverlay').style.display = 'none';
                        document.getElementById('gameSelectorContainer').classList.remove('hidden');
                    }, 1500);
                } catch (error) {
                    console.error('支付错误:', error);
                    Helpers.showMessage('支付失败: ' + error.message, 'error');
                    Helpers.showLoader(false);
                }
            }
        };
        
        // 飞机游戏类
        class PlaneGame {
            constructor() {
                this.canvas = document.getElementById('planeCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = 400;
                this.canvas.height = 600;
                
                this.isRunning = false;
                this.isPaused = false;
                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('planeGameHighScore') || '0');
                
                this.player = {
                    x: this.canvas.width / 2 - 25,
                    y: this.canvas.height - 70,
                    width: 50,
                    height: 50,
                    speed: 5
                };
                
                this.bullets = [];
                this.enemies = [];
                this.enemySpeed = 2;
                this.enemySpawnRate = 0.02;
                this.lastFrame = 0;
                
                // 控制按钮
                this.leftBtn = document.getElementById('leftBtn');
                this.rightBtn = document.getElementById('rightBtn');
                this.shootBtn = document.getElementById('shootBtn');
                
                // 按键状态
                this.keys = {
                    left: false,
                    right: false
                };
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // 键盘控制
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowLeft') this.keys.left = true;
                    if (e.key === 'ArrowRight') this.keys.right = true;
                    if (e.key === ' ') this.shoot();
                    if (e.key === 'p' || e.key === 'P') this.togglePause();
                });
                
                window.addEventListener('keyup', (e) => {
                    if (e.key === 'ArrowLeft') this.keys.left = false;
                    if (e.key === 'ArrowRight') this.keys.right = false;
                });
                
                // 触摸控制
                this.leftBtn.addEventListener('touchstart', () => this.keys.left = true);
                this.leftBtn.addEventListener('touchend', () => this.keys.left = false);
                this.rightBtn.addEventListener('touchstart', () => this.keys.right = true);
                this.rightBtn.addEventListener('touchend', () => this.keys.right = false);
                this.shootBtn.addEventListener('touchstart', () => this.shoot());
                
                // 鼠标控制
                this.leftBtn.addEventListener('mousedown', () => this.keys.left = true);
                this.leftBtn.addEventListener('mouseup', () => this.keys.left = false);
                this.leftBtn.addEventListener('mouseleave', () => this.keys.left = false);
                this.rightBtn.addEventListener('mousedown', () => this.keys.right = true);
                this.rightBtn.addEventListener('mouseup', () => this.keys.right = false);
                this.rightBtn.addEventListener('mouseleave', () => this.keys.right = false);
                this.shootBtn.addEventListener('click', () => this.shoot());
                
                // 窗口大小变化
                window.addEventListener('resize', () => this.handleResize());
                this.handleResize();
            }
            
            handleResize() {
                const container = document.getElementById('planeGameContainer');
                const containerWidth = container.clientWidth;
                
                if (containerWidth < this.canvas.width) {
                    const scale = containerWidth / this.canvas.width;
                    this.canvas.style.width = `${containerWidth}px`;
                    this.canvas.style.height = `${this.canvas.height * scale}px`;
                } else {
                    this.canvas.style.width = `${this.canvas.width}px`;
                    this.canvas.style.height = `${this.canvas.height}px`;
                }
            }
            
            togglePause() {
                this.isPaused = !this.isPaused;
                
                if (!this.isPaused && this.isRunning) {
                    this.lastFrame = performance.now();
                    this.gameLoop();
                }
            }
            
            start() {
                this.isRunning = true;
                this.score = 0;
                this.bullets = [];
                this.enemies = [];
                this.player.x = this.canvas.width / 2 - 25;
                this.lastFrame = performance.now();
                this.gameLoop();
            }
            
            stop() {
                this.isRunning = false;
                
                // 更新最高分
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('planeGameHighScore', this.highScore.toString());
                }
                
                // 绘制游戏结束界面
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = '30px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('游戏结束', this.canvas.width/2, this.canvas.height/2 - 30);
                
                this.ctx.font = '20px Arial';
                this.ctx.fillText(`得分: ${this.score}`, this.canvas.width/2, this.canvas.height/2 + 10);
                this.ctx.fillText(`最高分: ${this.highScore}`, this.canvas.width/2, this.canvas.height/2 + 40);
                
                this.ctx.font = '16px Arial';
                this.ctx.fillText('点击屏幕重新开始', this.canvas.width/2, this.canvas.height/2 + 80);
                
                // 添加重新开始的点击事件
                const restartHandler = () => {
                    this.canvas.removeEventListener('click', restartHandler);
                    this.start();
                };
                
                this.canvas.addEventListener('click', restartHandler);
            }
            
            shoot() {
                if (!this.isRunning || this.isPaused) return;
                
                this.bullets.push({
                    x: this.player.x + this.player.width / 2 - 2.5,
                    y: this.player.y,
                    width: 5,
                    height: 10,
                    speed: 7
                });
            }
            
            update(deltaTime) {
                if (this.isPaused) return;
                
                // 更新飞机位置
                if (this.keys.left) {
                    this.player.x -= this.player.speed;
                }
                if (this.keys.right) {
                    this.player.x += this.player.speed;
                }
                
                // 边界检查
                if (this.player.x < 0) {
                    this.player.x = 0;
                }
                if (this.player.x > this.canvas.width - this.player.width) {
                    this.player.x = this.canvas.width - this.player.width;
                }
                
                // 更新子弹位置
                this.bullets = this.bullets.filter(bullet => {
                    bullet.y -= bullet.speed;
                    return bullet.y > -bullet.height;
                });
                
                // 生成敌机
                if (Math.random() < this.enemySpawnRate) {
                    this.enemies.push({
                        x: Math.random() * (this.canvas.width - 40),
                        y: -40,
                        width: 40,
                        height: 40,
                        speed: this.enemySpeed + Math.random() * 2
                    });
                }
                
                // 更新敌机位置
                this.enemies = this.enemies.filter(enemy => {
                    enemy.y += enemy.speed;
                    
                    // 检查与子弹的碰撞
                    for (let i = 0; i < this.bullets.length; i++) {
                        const bullet = this.bullets[i];
                        if (this.checkCollision(bullet, enemy)) {
                            this.bullets.splice(i, 1);
                            this.score++;
                            return false;
                        }
                    }
                    
                    // 检查与玩家的碰撞
                    if (this.checkCollision(this.player, enemy)) {
                        this.stop();
                        return false;
                    }
                    
                    return enemy.y < this.canvas.height;
                });
                
                // 随着分数增加难度
                this.enemySpawnRate = Math.min(0.05, 0.02 + this.score / 1000);
                this.enemySpeed = Math.min(6, 2 + this.score / 100);
            }
            
            checkCollision(obj1, obj2) {
                return obj1.x < obj2.x + obj2.width &&
                       obj1.x + obj1.width > obj2.x &&
                       obj1.y < obj2.y + obj2.height &&
                       obj1.y + obj1.height > obj2.y;
            }
            
            draw() {
                // 清空画布
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 绘制玩家飞机
                this.ctx.fillStyle = '#3366cc';
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x + this.player.width / 2, this.player.y);
                this.ctx.lineTo(this.player.x, this.player.y + this.player.height);
                this.ctx.lineTo(this.player.x + this.player.width, this.player.y + this.player.height);
                this.ctx.closePath();
                this.ctx.fill();
                
                // 绘制飞机细节
                this.ctx.fillStyle = '#6699ff';
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x + this.player.width / 2, this.player.y + 10);
                this.ctx.lineTo(this.player.x + 10, this.player.y + this.player.height - 5);
                this.ctx.lineTo(this.player.x + this.player.width - 10, this.player.y + this.player.height - 5);
                this.ctx.closePath();
                this.ctx.fill();
                
                // 绘制子弹
                this.ctx.fillStyle = '#ff0000';
                this.bullets.forEach(bullet => {
                    this.ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                });
                
                // 绘制敌机
                this.enemies.forEach(enemy => {
                    // 敌机主体
                    this.ctx.fillStyle = '#33cc33';
                    this.ctx.beginPath();
                    this.ctx.moveTo(enemy.x + enemy.width / 2, enemy.y + enemy.height);
                    this.ctx.lineTo(enemy.x, enemy.y);
                    this.ctx.lineTo(enemy.x + enemy.width, enemy.y);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // 敌机细节
                    this.ctx.fillStyle = '#66ff66';
                    this.ctx.beginPath();
                    this.ctx.moveTo(enemy.x + enemy.width / 2, enemy.y + enemy.height - 10);
                    this.ctx.lineTo(enemy.x + 10, enemy.y + 5);
                    this.ctx.lineTo(enemy.x + enemy.width - 10, enemy.y + 5);
                    this.ctx.closePath();
                    this.ctx.fill();
                });
                
                // 绘制分数
                this.ctx.fillStyle = '#000000';
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`分数: ${this.score}`, 10, 25);
                
                // 绘制最高分
                this.ctx.fillText(`最高分: ${this.highScore}`, 10, 50);
                
                // 如果暂停，绘制暂停提示
                if (this.isPaused) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '30px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('已暂停', this.canvas.width/2, this.canvas.height/2);
                    this.ctx.font = '16px Arial';
                    this.ctx.fillText('按 P 键继续', this.canvas.width/2, this.canvas.height/2 + 30);
                }
            }
            
            gameLoop(timestamp) {
                if (!this.isRunning) return;
                
                const now = timestamp || performance.now();
                const deltaTime = now - this.lastFrame;
                this.lastFrame = now;
                
                // 限制最大时间步长
                const maxDelta = 32; // 约30fps的帧时间
                const clampedDelta = Math.min(deltaTime, maxDelta);
                
                this.update(clampedDelta);
                this.draw();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
        }
        
        // 弹珠游戏类
        class MarbleGame {
            constructor() {
                this.canvas = document.getElementById('marbleCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                
                this.gameActive = false;
                this.level = 1;
                this.maxLevel = 5;
                this.attempts = 0;
                
                this.marble = {
                    x: 100,
                    y: this.canvas.height - 100,
                    radius: 15,
                    color: '#ff4444',
                    velocity: { x: 0, y: 0 },
                    launched: false
                };
                
                this.hole = {
                    x: this.canvas.width - 100,
                    y: 100,
                    radius: 20,
                    color: '#333333'
                };
                
                this.obstacles = [];
                this.generateLevel(this.level);
                
                this.friction = 0.98;
                this.isDragging = false;
                this.dragStart = { x: 0, y: 0 };
                this.dragDistance = 0;
                this.message = null;
                this.messageTimeout = null;
                
                this.setupEventListeners();
            }
            
            resize() {
                this.canvas.width = Math.min(800, window.innerWidth - 40);
                this.canvas.height = Math.min(600, window.innerHeight - 150);
            }
            
            setupEventListeners() {
                // 触摸事件
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startDrag({
                        clientX: e.touches[0].clientX,
                        clientY: e.touches[0].clientY
                    });
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.drag({
                        clientX: e.touches[0].clientX,
                        clientY: e.touches[0].clientY
                    });
                });
                
                this.canvas.addEventListener('touchend', () => {
                    this.launch();
                });
                
                // 鼠标事件
                this.canvas.addEventListener('mousedown', (e) => {
                    this.startDrag(e);
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    this.drag(e);
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.launch();
                });
                
                // 窗口大小变化
                window.addEventListener('resize', () => {
                    this.resize();
                    this.resetLevel();
                });
            }
            
            startDrag(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // 只有当弹珠静止时才能拖动
                if (!this.marble.launched && this.distance(x, y, this.marble.x, this.marble.y) <= this.marble.radius) {
                    this.isDragging = true;
                    this.dragStart.x = x;
                    this.dragStart.y = y;
                    this.dragDistance = 0;
                }
            }
            
            drag(e) {
                if (!this.isDragging) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                this.dragStart.x = x;
                this.dragStart.y = y;
                
                // 计算拖动距离，用于力量显示
                const dx = this.marble.x - x;
                const dy = this.marble.y - y;
                this.dragDistance = Math.sqrt(dx*dx + dy*dy);
                
                // 限制最大拖动距离
                if (this.dragDistance > 150) {
                    const angle = Math.atan2(dy, dx);
                    this.dragStart.x = this.marble.x - Math.cos(angle) * 150;
                    this.dragStart.y = this.marble.y - Math.sin(angle) * 150;
                    this.dragDistance = 150;
                }
                
                // 持续重绘
                this.draw();
            }
            
            launch() {
                if (!this.isDragging) return;
                
                this.isDragging = false;
                this.attempts++;
                
                // 计算速度（与拖动方向相反）
                const dx = this.marble.x - this.dragStart.x;
                const dy = this.marble.y - this.dragStart.y;
                const powerFactor = 0.1; // 调整发射力度
                
                this.marble.velocity.x = dx * powerFactor;
                this.marble.velocity.y = dy * powerFactor;
                this.marble.launched = true;
                
                // 开始游戏循环
                this.gameLoop();
            }
            
            update() {
                if (!this.marble.launched) return;
                
                // 更新弹珠位置
                this.marble.x += this.marble.velocity.x;
                this.marble.y += this.marble.velocity.y;
                
                // 边界碰撞
                if (this.marble.x - this.marble.radius < 0) {
                    this.marble.x = this.marble.radius;
                    this.marble.velocity.x *= -0.8;
                } else if (this.marble.x + this.marble.radius > this.canvas.width) {
                    this.marble.x = this.canvas.width - this.marble.radius;
                    this.marble.velocity.x *= -0.8;
                }
                
                if (this.marble.y - this.marble.radius < 0) {
                    this.marble.y = this.marble.radius;
                    this.marble.velocity.y *= -0.8;
                } else if (this.marble.y + this.marble.radius > this.canvas.height) {
                    this.marble.y = this.canvas.height - this.marble.radius;
                    this.marble.velocity.y *= -0.8;
                }
                
                // 障碍物碰撞
                for (const obstacle of this.obstacles) {
                    if (this.checkObstacleCollision(this.marble, obstacle)) {
                        this.handleObstacleCollision(this.marble, obstacle);
                    }
                }
                
                // 速度衰减
                this.marble.velocity.x *= this.friction;
                this.marble.velocity.y *= this.friction;
                
                // 检测胜利 - 弹珠进洞
                const distToHole = this.distance(this.marble.x, this.marble.y, this.hole.x, this.hole.y);
                if (distToHole < this.hole.radius) {
                    this.levelComplete();
                    return;
                }
                
                // 检测停止条件
                if (Math.abs(this.marble.velocity.x) < 0.1 && Math.abs(this.marble.velocity.y) < 0.1) {
                    this.marble.launched = false;
                    this.marble.velocity.x = 0;
                    this.marble.velocity.y = 0;
                }
            }
            
            checkObstacleCollision(marble, obstacle) {
                // 矩形障碍物碰撞检测
                let testX = marble.x;
                let testY = marble.y;
                
                if (marble.x < obstacle.x) testX = obstacle.x;
                else if (marble.x > obstacle.x + obstacle.width) testX = obstacle.x + obstacle.width;
                
                if (marble.y < obstacle.y) testY = obstacle.y;
                else if (marble.y > obstacle.y + obstacle.height) testY = obstacle.y + obstacle.height;
                
                const distance = this.distance(marble.x, marble.y, testX, testY);
                return distance <= marble.radius;
            }
            
            handleObstacleCollision(marble, obstacle) {
                // 简化的碰撞响应
                // 确定碰撞点和碰撞法线
                let closestX = Math.max(obstacle.x, Math.min(marble.x, obstacle.x + obstacle.width));
                let closestY = Math.max(obstacle.y, Math.min(marble.y, obstacle.y + obstacle.height));
                
                // 碰撞恢复
                if (Math.abs(closestX - marble.x) < Math.abs(closestY - marble.y)) {
                    // 水平碰撞
                    marble.velocity.x *= -0.8;
                    if (marble.x < closestX) {
                        marble.x = closestX - marble.radius;
                    } else {
                        marble.x = closestX + marble.radius;
                    }
                } else {
                    // 垂直碰撞
                    marble.velocity.y *= -0.8;
                    if (marble.y < closestY) {
                        marble.y = closestY - marble.radius;
                    } else {
                        marble.y = closestY + marble.radius;
                    }
                }
            }
            
            levelComplete() {
                this.marble.launched = false;
                
                if (this.level === this.maxLevel) {
                    this.showMessage('恭喜！你完成了所有关卡！', 3000);
                    setTimeout(() => {
                        this.level = 1;
                        this.attempts = 0;
                        this.generateLevel(this.level);
                    }, 3000);
                } else {
                    this.level++;
                    this.showMessage(`完成关卡 ${this.level-1}！`, 2000);
                    this.generateLevel(this.level);
                }
            }
            
            resetLevel() {
                // 重置弹珠位置和属性
                this.marble.x = 100;
                this.marble.y = this.canvas.height - 100;
                this.marble.velocity.x = 0;
                this.marble.velocity.y = 0;
                this.marble.launched = false;
                
                // 重新生成关卡
                this.generateLevel(this.level);
            }
            
            generateLevel(level) {
                // 根据关卡生成障碍物和目标
                this.obstacles = [];
                
                // 根据关卡调整难度
                switch(level) {
                    case 1:
                        // 简单关卡 - 一个障碍物
                        this.hole.x = this.canvas.width - 100;
                        this.hole.y = 100;
                        
                        this.obstacles.push({
                            x: this.canvas.width / 2 - 50,
                            y: this.canvas.height / 2 - 20,
                            width: 100,
                            height: 40,
                            color: '#888888'
                        });
                        break;
                        
                    case 2:
                        // 两个障碍物
                        this.hole.x = this.canvas.width - 100;
                        this.hole.y = this.canvas.height - 100;
                        
                        this.obstacles.push({
                            x: this.canvas.width / 3 - 30,
                            y: this.canvas.height / 3,
                            width: 60,
                            height: 100,
                            color: '#888888'
                        });
                        
                        this.obstacles.push({
                            x: 2 * this.canvas.width / 3 - 30,
                            y: 2 * this.canvas.height / 3 - 100,
                            width: 60, 
                            height: 100,
                            color: '#888888'
                        });
                        break;
                        
                    case 3:
                        // 中等难度 - 迷宫形状
                        this.hole.x = this.canvas.width / 2;
                        this.hole.y = this.canvas.height / 2;
                        
                        // 上墙
                        this.obstacles.push({
                            x: 0,
                            y: this.canvas.height / 3 - 20,
                            width: 2 * this.canvas.width / 3,
                            height: 40,
                            color: '#888888'
                        });
                        
                        // 下墙
                        this.obstacles.push({
                            x: this.canvas.width / 3,
                            y: 2 * this.canvas.height / 3 - 20,
                            width: 2 * this.canvas.width / 3,
                            height: 40,
                            color: '#888888'
                        });
                        break;
                        
                    case 4:
                        // 困难 - 复杂障碍
                        this.hole.x = this.canvas.width - 80;
                        this.hole.y = this.canvas.height - 80;
                        
                        // 创建迷宫样式的障碍
                        for (let i = 0; i < 3; i++) {
                            this.obstacles.push({
                                x: (i + 1) * this.canvas.width / 4 - 20,
                                y: 100,
                                width: 40,
                                height: this.canvas.height - 200,
                                color: '#888888'
                            });
                        }
                        
                        // 横向连接
                        for (let i = 0; i < 2; i++) {
                            this.obstacles.push({
                                x: 100,
                                y: (i + 1) * this.canvas.height / 3,
                                width: this.canvas.width - 200,
                                height: 20,
                                color: '#888888'
                            });
                        }
                        break;
                        
                    case 5:
                        // 最终关卡 - 非常困难
                        this.hole.x = this.canvas.width / 2;
                        this.hole.y = this.canvas.height / 2;
                        
                        // 创建一圈障碍，中间开口
                        const thickness = 20;
                        const gapSize = 60;
                        const centerX = this.canvas.width / 2;
                        const centerY = this.canvas.height / 2;
                        const radius = Math.min(centerX, centerY) - 50;
                        
                        // 上部
                        this.obstacles.push({
                            x: centerX - radius,
                            y: centerY - radius - thickness,
                            width: 2 * radius,
                            height: thickness,
                            color: '#888888'
                        });
                        
                        // 下部
                        this.obstacles.push({
                            x: centerX - radius,
                            y: centerY + radius,
                            width: 2 * radius,
                            height: thickness,
                            color: '#888888'
                        });
                        
                        // 左部（带开口）
                        this.obstacles.push({
                            x: centerX - radius - thickness,
                            y: centerY - radius,
                            width: thickness,
                            height: (radius * 2 - gapSize) / 2,
                            color: '#888888'
                        });
                        
                        this.obstacles.push({
                            x: centerX - radius - thickness,
                            y: centerY + gapSize / 2,
                            width: thickness,
                            height: (radius * 2 - gapSize) / 2,
                            color: '#888888'
                        });
                        
                        // 右部
                        this.obstacles.push({
                            x: centerX + radius,
                            y: centerY - radius,
                            width: thickness,
                            height: 2 * radius,
                            color: '#888888'
                        });
                        break;
                }
                
                // 重置弹珠位置
                this.marble.x = 100;
                this.marble.y = this.canvas.height - 100;
                this.marble.velocity.x = 0;
                this.marble.velocity.y = 0;
                this.marble.launched = false;
                
                // 绘制初始场景
                this.draw();
            }
            
            showMessage(text, duration = 2000) {
                this.message = {
                    text: text,
                    alpha: 1.0
                };
                
                clearTimeout(this.messageTimeout);
                this.messageTimeout = setTimeout(() => {
                    this.message = null;
                }, duration);
                
                // 确保消息显示
                this.draw();
                if (!this.marble.launched && !this.isDragging) {
                    this.gameLoop();
                }
            }
            
            drawMessage() {
                if (!this.message) return;
                
                this.ctx.save();
                this.ctx.globalAlpha = this.message.alpha;
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillStyle = 'white';
                this.ctx.font = '24px Arial';
                this.ctx.fillText(this.message.text, this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.restore();
                
                // 消息淡出效果
                if (this.message.alpha > 0) {
                    this.message.alpha -= 0.01;
                    if (this.message.alpha <= 0) {
                        this.message = null;
                    }
                }
            }
            
            distance(x1, y1, x2, y2) {
                return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            }
            
            draw() {
                // 清空画布
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 绘制背景
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#7cbf6d');
                gradient.addColorStop(1, '#5a9f5e');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 绘制目标洞口（带阴影）
                this.ctx.beginPath();
                this.ctx.arc(this.hole.x, this.hole.y, this.hole.radius + 3, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                this.ctx.fill();
                
                this.ctx.beginPath();
                this.ctx.arc(this.hole.x, this.hole.y, this.hole.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = this.hole.color;
                this.ctx.fill();
                
                // 绘制障碍物
                this.obstacles.forEach(obstacle => {
                    // 阴影
                    this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    this.ctx.fillRect(obstacle.x + 3, obstacle.y + 3, obstacle.width, obstacle.height);
                    
                    // 障碍物
                    this.ctx.fillStyle = obstacle.color;
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                });
                
                // 绘制弹珠
                this.ctx.beginPath();
                this.ctx.arc(this.marble.x, this.marble.y, this.marble.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = this.marble.color;
                this.ctx.fill();
                
                // 添加弹珠高光效果
                this.ctx.beginPath();
                this.ctx.arc(this.marble.x - this.marble.radius/3, this.marble.y - this.marble.radius/3, 
                             this.marble.radius/4, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(255,255,255,0.8)';
                this.ctx.fill();
                
                // 绘制瞄准线
                if (this.isDragging) {
                    // 计算力量比例（0-1）
                    const powerRatio = Math.min(this.dragDistance / 150, 1);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.marble.x, this.marble.y);
                    this.ctx.lineTo(this.dragStart.x, this.dragStart.y);
                    this.ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    // 绘制预测路径点
                    this.ctx.beginPath();
                    const dx = this.marble.x - this.dragStart.x;
                    const dy = this.marble.y - this.dragStart.y;
                    const power = 0.1; // 与 launch 方法中相同
                    let predX = this.marble.x, predY = this.marble.y;
                    let predVelX = dx * power, predVelY = dy * power;
                    
                    for (let i = 0; i < 10; i++) {
                        predX += predVelX;
                        predY += predVelY;
                        predVelX *= this.friction;
                        predVelY *= this.friction;
                        
                        this.ctx.fillStyle = `rgba(255,255,255,${0.7 - i * 0.07})`;
                        this.ctx.beginPath();
                        this.ctx.arc(predX, predY, 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    // 力量条
                    const barWidth = 100;
                    const barHeight = 10;
                    const barX = this.canvas.width - barWidth - 20;
                    const barY = 20;
                    
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    const powerColor = this.getPowerColor(powerRatio);
                    this.ctx.fillStyle = powerColor;
                    this.ctx.fillRect(barX, barY, barWidth * powerRatio, barHeight);
                    
                    // 力量文字
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('力量', barX - 30, barY + barHeight / 2 + 4);
                }
                
                // 游戏信息
                this.ctx.fillStyle = 'white';
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`关卡: ${this.level}/${this.maxLevel}`, 20, 30);
                this.ctx.fillText(`尝试次数: ${this.attempts}`, 20, 55);
                
                // 游戏说明
                this.ctx.textAlign = 'left';
                this.ctx.font = '14px Arial';
                this.ctx.fillText('拖动弹珠并释放来发射', 20, this.canvas.height - 20);
                
                // 绘制消息
                this.drawMessage();
            }
            
            getPowerColor(ratio) {
                if (ratio < 0.3) return '#4CAF50'; // 绿色
                if (ratio < 0.6) return '#FFC107'; // 黄色
                return '#F44336'; // 红色
            }
            
            gameLoop(timestamp) {
                if (!this.gameActive) return;
                
                const now = timestamp || performance.now();
                const deltaTime = now - (this.lastTime || now);
                this.lastTime = now;
                
                // 更新游戏状态
                this.update();
                
                // 绘制场景
                this.draw();
                
                // 如果弹珠在移动或正在拖动，继续循环
                if (this.marble.launched || this.isDragging || this.message) {
                    requestAnimationFrame(this.gameLoop.bind(this));
                }
            }
            
            start() {
                this.gameActive = true;
                this.draw();
            }
            
            stop() {
                this.gameActive = false;
            }
        }

        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            // 设置官方钱包地址（替换为您的实际地址）
            const walletAddress = 'YOUR_SOLANA_WALLET_ADDRESS';
            document.querySelector('.banner-wallet').textContent = walletAddress;
            
            // 横幅切换
            const banner = document.getElementById('officialBanner');
            const toggleBtn = document.getElementById('bannerToggle');
            
            toggleBtn.addEventListener('click', function() {
                banner.classList.toggle('banner-collapsed');
                toggleBtn.textContent = banner.classList.contains('banner-collapsed') ? '▼' : '▲';
            });
            
            // 初始化钱包管理
            WalletManager.initialize();
            
            // 隐藏所有游戏容器
            document.getElementById('planeGameContainer').classList.add('hidden');
            document.getElementById('marbleGameContainer').classList.add('hidden');
            
            // 游戏实例
            const planeGame = new PlaneGame();
            const marbleGame = new MarbleGame();
            
            // 设置游戏选择
            document.getElementById('planeGameOption').addEventListener('click', function() {
                document.getElementById('gameSelectorContainer').classList.add('hidden');
                document.getElementById('planeGameContainer').classList.remove('hidden');
                planeGame.start();
            });
            
            document.getElementById('marbleGameOption').addEventListener('click', function() {
                document.getElementById('gameSelectorContainer').classList.add('hidden');
                document.getElementById('marbleGameContainer').classList.remove('hidden');
                marbleGame.start();
            });
            
            // 返回选择按钮
            document.getElementById('backToSelector').addEventListener('click', function() {
                planeGame.stop();
                document.getElementById('planeGameContainer').classList.add('hidden');
                document.getElementById('gameSelectorContainer').classList.remove('hidden');
            });
            
            document.getElementById('backToSelectorMarble').addEventListener('click', function() {
                marbleGame.stop();
                document.getElementById('marbleGameContainer').classList.add('hidden');
                document.getElementById('gameSelectorContainer').classList.remove('hidden');
            });
            
            // 防止在触摸设备上缩放
            document.addEventListener('touchmove', function(e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // 错误处理
            window.addEventListener('error', function(e) {
                console.error('全局错误:', e.message);
                Helpers.showMessage('应用发生错误，请刷新页面', 'error');
            });
        });
    </script>
</body>
</html>
