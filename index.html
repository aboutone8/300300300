<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="csrf-token" content="">
    <!-- ä¿®æ”¹CSPä»¥å…è®¸Solanaé’±åŒ…APIå’Œå¤–éƒ¨è„šæœ¬ -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://cdn.jsdelivr.net https://unpkg.com 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src https://* wss://*;">
    <title>å®˜æ–¹æ¸¸æˆå¹³å°</title>
    <!-- åŠ è½½Solana Web3.js -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <!-- åŠ è½½SPL Token -->
    <script src="https://unpkg.com/@solana/spl-token@latest/lib/index.iife.min.js"></script>
    <style>
        :root {
            --primary-color: #4CAF50;
            --primary-hover: #45a049;
            --accent-color: #9945FF;
            --danger-color: #f44336;
            --warning-color: #ff9800;
            --banner-bg: #d32f2f;
            --banner-text: #ffeb3b;
            --text-light: #ffffff;
            --text-dark: #333333;
            --bg-light: #f5f5f5;
            --overlay-bg: rgba(0, 0, 0, 0.85);
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        html, body {
            height: 100%;
            font-family: 'PingFang SC', 'Microsoft YaHei', Arial, sans-serif;
            background-color: var(--bg-light);
            color: var(--text-dark);
            overflow-x: hidden;
        }
        
        /* æ¨ªå¹…æ ·å¼ */
        .banner {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: var(--banner-bg);
            color: var(--banner-text);
            font-weight: bold;
            padding: 10px 20px;
            text-align: center;
            z-index: 9999;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            font-size: 0.9rem;
            transition: transform 0.3s;
        }
        
        .banner-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: transparent;
            border: none;
            color: var(--banner-text);
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 10000;
        }
        
        .banner-collapsed {
            transform: translateY(-100%);
        }
        
        .banner-info {
            margin: 5px 0;
        }
        
        .banner-wallet {
            font-family: monospace;
            background: rgba(255,255,255,0.2);
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
            margin-top: 5px;
        }
        
        /* æ”¯ä»˜ç›¸å…³æ ·å¼ */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--overlay-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .payment-box {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
            max-width: 90%;
            width: 450px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        }
        
        .payment-title {
            margin-bottom: 1.5rem;
            font-size: 1.5rem;
            color: var(--text-dark);
        }
        
        .payment-button {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.2rem;
            border-radius: 5px;
            cursor: pointer;
            margin: 1rem 0;
            transition: background-color 0.2s, transform 0.1s;
        }
        
        .payment-button:hover {
            filter: brightness(1.1);
        }
        
        .payment-button:active {
            transform: scale(0.98);
        }
        
        .connect-wallet-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 1rem;
        }
        
        .wallet-status {
            margin: 10px 0;
            font-size: 0.9rem;
            color: #666;
        }
        
        .wallet-address {
            font-family: monospace;
            word-break: break-all;
            background: #f5f5f5;
            padding: 5px;
            border-radius: 4px;
            margin: 5px 0;
            font-size: 0.8rem;
        }
        
        /* æé†’æ¶ˆæ¯ */
        .alert-message {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            z-index: 10001;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
        }
        
        .alert-success {
            background-color: var(--primary-color);
        }
        
        .alert-error {
            background-color: var(--danger-color);
        }
        
        .alert-warning {
            background-color: var(--warning-color);
            color: #333;
        }
        
        /* åŠ è½½æŒ‡ç¤ºå™¨ */
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid var(--accent-color);
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
            display: none;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* å¤åˆ¶æŒ‰é’® */
        .copy-btn {
            background: #e0e0e0;
            border: none;
            padding: 4px 8px;
            margin-left: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.8rem;
        }
        
        .copy-btn:hover {
            background: #d0d0d0;
        }
        
        /* æ¸¸æˆé€‰æ‹©å™¨ */
        .game-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            max-width: 800px;
            margin: 30px auto;
            padding: 20px;
        }
        
        .game-option {
            background: white;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .game-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        
        .game-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--accent-color);
        }
        
        .game-title {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: var(--text-dark);
        }
        
        .game-description {
            font-size: 0.9rem;
            color: #666;
        }
        
        /* å®¹å™¨ */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .game-container {
            margin-top: 70px;
            text-align: center;
            position: relative;
        }
        
        /* æŒ‰é’®æ ·å¼ */
        .action-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .action-btn:hover {
            background-color: var(--primary-hover);
        }
        
        /* æ•ˆæœæ ·å¼ */
        .hidden {
            display: none !important;
        }
        
        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 768px) {
            .game-selector {
                grid-template-columns: 1fr;
            }
            
            .payment-box {
                width: 90%;
                padding: 1.5rem;
            }
            
            .game-title {
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <!-- å®˜æ–¹å£°æ˜æ¨ªå¹… -->
    <div id="officialBanner" class="banner">
        <div class="banner-info">å®˜æ–¹å£°æ˜ï¼šæœ¬æ¸¸æˆä»…ä¾›å¨±ä¹ï¼Œè¯·ç†æ€§æ¸¸æˆã€‚</div>
        <div>å®˜æ–¹é’±åŒ…åœ°å€: <span class="banner-wallet">YOUR_SOLANA_WALLET_ADDRESS</span>
            <button class="copy-btn" onclick="copyWalletAddress()">å¤åˆ¶</button>
        </div>
    </div>
    <button id="bannerToggle" class="banner-toggle">â–²</button>
    
    <!-- å¼¹å‡ºæ¶ˆæ¯å®¹å™¨ -->
    <div id="alertContainer" class="alert-message"></div>
    
    <!-- æ”¯ä»˜ç•Œé¢ -->
    <div id="paymentOverlay" class="overlay">
        <div class="payment-box">
            <h2 class="payment-title">å¼€å§‹æ¸¸æˆ</h2>
            <p>è¯·ä»˜è´¹1æšUSDCå¼€å§‹æ¸¸æˆ</p>
            
            <div id="walletSection">
                <button id="connectWalletBtn" class="connect-wallet-btn">è¿æ¥é’±åŒ…</button>
                <div id="walletStatus" class="wallet-status">æœªè¿æ¥é’±åŒ…</div>
                <div id="walletAddress" class="wallet-address hidden"></div>
            </div>
            
            <div id="paymentActions" class="hidden">
                <button id="payButton" class="payment-button">æ”¯ä»˜1 USDC</button>
                <div id="loader" class="loader"></div>
                <p id="paymentNotice">è¯·ç¡®ä¿æ‚¨çš„é’±åŒ…ä¸­æœ‰è¶³å¤Ÿçš„USDCï¼Œå¹¶å·²æˆæƒæ­¤åº”ç”¨ä½¿ç”¨æ‚¨çš„é’±åŒ…ã€‚</p>
            </div>
        </div>
    </div>
    
    <!-- æ¸¸æˆé€‰æ‹©ç•Œé¢ -->
    <div id="gameSelectorContainer" class="container game-container hidden">
        <h1>é€‰æ‹©ä¸€ä¸ªæ¸¸æˆ</h1>
        <div class="game-selector">
            <div id="planeGameOption" class="game-option">
                <div class="game-icon">âœˆï¸</div>
                <h3 class="game-title">é£æœºå¤§æˆ˜</h3>
                <p class="game-description">æ§åˆ¶æ‚¨çš„é£æœºï¼Œå‡»è½æ•Œæœºè·å–é«˜åˆ†ï¼</p>
            </div>
            <div id="marbleGameOption" class="game-option">
                <div class="game-icon">ğŸ”®</div>
                <h3 class="game-title">å¼¹ç æ¸¸æˆ</h3>
                <p class="game-description">å‘å°„å¼¹ç ï¼Œç©¿è¿‡éšœç¢ç‰©åˆ°è¾¾ç›®æ ‡ï¼</p>
            </div>
        </div>
    </div>
    
    <!-- é£æœºæ¸¸æˆå®¹å™¨ -->
    <div id="planeGameContainer" class="game-container hidden">
        <canvas id="planeCanvas"></canvas>
        <div class="control-panel">
            <button class="control-btn" id="leftBtn">â†</button>
            <button class="control-btn" id="shootBtn">ğŸ”«</button>
            <button class="control-btn" id="rightBtn">â†’</button>
        </div>
        <button id="backToSelector" class="action-btn">è¿”å›é€‰æ‹©</button>
    </div>
    
    <!-- å¼¹ç æ¸¸æˆå®¹å™¨ -->
    <div id="marbleGameContainer" class="game-container hidden">
        <canvas id="marbleCanvas"></canvas>
        <button id="backToSelectorMarble" class="action-btn">è¿”å›é€‰æ‹©</button>
    </div>
    
    <script>
        // å¸¸é‡å®šä¹‰
        const RECEIVER_WALLET_ADDRESS = 'YOUR_SOLANA_WALLET_ADDRESS'; // æ›¿æ¢ä¸ºæ‚¨çš„é’±åŒ…åœ°å€
        const USDC_MINT_ADDRESS = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'; // Solanaä¸»ç½‘USDCä»£å¸åœ°å€
        
        // å·¥å…·å‡½æ•°
        const Helpers = {
            showMessage: function(message, type = 'success') {
                const alert = document.getElementById('alertContainer');
                alert.textContent = message;
                alert.className = `alert-message alert-${type}`;
                alert.style.display = 'block';
                
                setTimeout(() => {
                    alert.style.display = 'none';
                }, 5000);
            },
            
            showLoader: function(show) {
                document.getElementById('loader').style.display = show ? 'block' : 'none';
                if (show) {
                    document.getElementById('payButton').disabled = true;
                } else {
                    document.getElementById('payButton').disabled = false;
                }
            }
        };
        
        // å¤åˆ¶é’±åŒ…åœ°å€
        function copyWalletAddress() {
            const walletAddress = document.querySelector('.banner-wallet').textContent;
            navigator.clipboard.writeText(walletAddress)
                .then(() => Helpers.showMessage('é’±åŒ…åœ°å€å·²å¤åˆ¶', 'success'))
                .catch(err => Helpers.showMessage('å¤åˆ¶å¤±è´¥: ' + err.message, 'error'));
        }
        
        // é’±åŒ…è¿æ¥ä¸æ”¯ä»˜å¤„ç†
        const WalletManager = {
            provider: null,
            walletConnected: false,
            connection: null,
            
            initialize: function() {
                // æ£€æŸ¥æ˜¯å¦æœ‰Phantomé’±åŒ…æ’ä»¶
                if (window.solana && window.solana.isPhantom) {
                    this.provider = window.solana;
                    
                    // è¿æ¥åˆ°Solanaç½‘ç»œ
                    this.connection = new solanaWeb3.Connection(
                        solanaWeb3.clusterApiUrl('mainnet-beta'),
                        'confirmed'
                    );
                    
                    // ç›‘å¬é’±åŒ…è¿æ¥çŠ¶æ€å˜åŒ–
                    this.provider.on('connect', () => this.onConnect());
                    this.provider.on('disconnect', () => this.onDisconnect());
                    
                    // æ£€æŸ¥æ˜¯å¦å·²è¿æ¥
                    if (this.provider.isConnected) {
                        this.onConnect();
                    }
                    
                    document.getElementById('connectWalletBtn').addEventListener('click', () => {
                        this.connectWallet();
                    });
                    
                    document.getElementById('payButton').addEventListener('click', () => {
                        this.makePayment();
                    });
                } else {
                    document.getElementById('walletStatus').textContent = 'è¯·å®‰è£…Phantomé’±åŒ…æ’ä»¶';
                    Helpers.showMessage('è¯·å®‰è£…Phantomé’±åŒ…æ’ä»¶ååˆ·æ–°é¡µé¢', 'warning');
                }
            },
            
            connectWallet: async function() {
                try {
                    Helpers.showLoader(true);
                    await this.provider.connect();
                    Helpers.showLoader(false);
                } catch (error) {
                    console.error('è¿æ¥é’±åŒ…é”™è¯¯:', error);
                    Helpers.showMessage('è¿æ¥é’±åŒ…å¤±è´¥: ' + error.message, 'error');
                    Helpers.showLoader(false);
                }
            },
            
            onConnect: function() {
                this.walletConnected = true;
                const publicKey = this.provider.publicKey.toString();
                
                document.getElementById('walletStatus').textContent = 'é’±åŒ…å·²è¿æ¥';
                document.getElementById('walletAddress').textContent = publicKey;
                document.getElementById('walletAddress').classList.remove('hidden');
                document.getElementById('connectWalletBtn').textContent = 'å·²è¿æ¥';
                document.getElementById('connectWalletBtn').disabled = true;
                document.getElementById('paymentActions').classList.remove('hidden');
                
                Helpers.showMessage('é’±åŒ…è¿æ¥æˆåŠŸ', 'success');
            },
            
            onDisconnect: function() {
                this.walletConnected = false;
                document.getElementById('walletStatus').textContent = 'é’±åŒ…å·²æ–­å¼€è¿æ¥';
                document.getElementById('walletAddress').classList.add('hidden');
                document.getElementById('connectWalletBtn').textContent = 'è¿æ¥é’±åŒ…';
                document.getElementById('connectWalletBtn').disabled = false;
                document.getElementById('paymentActions').classList.add('hidden');
                
                Helpers.showMessage('é’±åŒ…å·²æ–­å¼€è¿æ¥', 'warning');
            },
            
            makePayment: async function() {
                if (!this.walletConnected) {
                    Helpers.showMessage('è¯·å…ˆè¿æ¥é’±åŒ…', 'warning');
                    return;
                }
                
                try {
                    Helpers.showLoader(true);
                    
                    // è·å–USDC Tokenä¿¡æ¯
                    const usdcMint = new solanaWeb3.PublicKey(USDC_MINT_ADDRESS);
                    const receiverWallet = new solanaWeb3.PublicKey(RECEIVER_WALLET_ADDRESS);
                    const userWallet = this.provider.publicKey;
                    
                    // æŸ¥æ‰¾ç”¨æˆ·çš„USDCä»£å¸è´¦æˆ·
                    const userTokenAccounts = await this.connection.getParsedTokenAccountsByOwner(
                        userWallet,
                        { mint: usdcMint }
                    );
                    
                    if (userTokenAccounts.value.length === 0) {
                        throw new Error('æ‚¨çš„é’±åŒ…ä¸­æ²¡æœ‰USDCä»£å¸è´¦æˆ·');
                    }
                    
                    const userTokenAccount = userTokenAccounts.value[0].pubkey;
                    
                    // æŸ¥æ‰¾æ¥æ”¶è€…çš„USDCä»£å¸è´¦æˆ·
                    const receiverTokenAccounts = await this.connection.getParsedTokenAccountsByOwner(
                        receiverWallet,
                        { mint: usdcMint }
                    );
                    
                    if (receiverTokenAccounts.value.length === 0) {
                        throw new Error('æ¥æ”¶è€…é’±åŒ…æ²¡æœ‰USDCä»£å¸è´¦æˆ·');
                    }
                    
                    const receiverTokenAccount = receiverTokenAccounts.value[0].pubkey;
                    
                    // åˆ›å»ºè½¬è´¦æŒ‡ä»¤
                    const transaction = new solanaWeb3.Transaction().add(
                        splToken.Token.createTransferInstruction(
                            splToken.TOKEN_PROGRAM_ID,
                            userTokenAccount,
                            receiverTokenAccount,
                            userWallet,
                            [],
                            1000000 // USDCæœ‰6ä½å°æ•°ï¼Œ1 USDC = 1000000
                        )
                    );
                    
                    // æ·»åŠ æœ€è¿‘çš„åŒºå—å“ˆå¸Œ
                    transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;
                    transaction.feePayer = userWallet;
                    
                    // å‘é€äº¤æ˜“
                    const signed = await this.provider.signTransaction(transaction);
                    const signature = await this.connection.sendRawTransaction(signed.serialize());
                    
                    // ç­‰å¾…ç¡®è®¤
                    await this.connection.confirmTransaction(signature);
                    
                    Helpers.showLoader(false);
                    Helpers.showMessage('æ”¯ä»˜æˆåŠŸï¼æ¸¸æˆå³å°†å¼€å§‹', 'success');
                    
                    // æ”¯ä»˜æˆåŠŸï¼Œæ˜¾ç¤ºæ¸¸æˆé€‰æ‹©ç•Œé¢
                    setTimeout(() => {
                        document.getElementById('paymentOverlay').style.display = 'none';
                        document.getElementById('gameSelectorContainer').classList.remove('hidden');
                    }, 1500);
                } catch (error) {
                    console.error('æ”¯ä»˜é”™è¯¯:', error);
                    Helpers.showMessage('æ”¯ä»˜å¤±è´¥: ' + error.message, 'error');
                    Helpers.showLoader(false);
                }
            }
        };
        
        // é£æœºæ¸¸æˆç±»
        class PlaneGame {
            constructor() {
                this.canvas = document.getElementById('planeCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = 400;
                this.canvas.height = 600;
                
                this.isRunning = false;
                this.isPaused = false;
                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('planeGameHighScore') || '0');
                
                this.player = {
                    x: this.canvas.width / 2 - 25,
                    y: this.canvas.height - 70,
                    width: 50,
                    height: 50,
                    speed: 5
                };
                
                this.bullets = [];
                this.enemies = [];
                this.enemySpeed = 2;
                this.enemySpawnRate = 0.02;
                this.lastFrame = 0;
                
                // æ§åˆ¶æŒ‰é’®
                this.leftBtn = document.getElementById('leftBtn');
                this.rightBtn = document.getElementById('rightBtn');
                this.shootBtn = document.getElementById('shootBtn');
                
                // æŒ‰é”®çŠ¶æ€
                this.keys = {
                    left: false,
                    right: false
                };
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // é”®ç›˜æ§åˆ¶
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowLeft') this.keys.left = true;
                    if (e.key === 'ArrowRight') this.keys.right = true;
                    if (e.key === ' ') this.shoot();
                    if (e.key === 'p' || e.key === 'P') this.togglePause();
                });
                
                window.addEventListener('keyup', (e) => {
                    if (e.key === 'ArrowLeft') this.keys.left = false;
                    if (e.key === 'ArrowRight') this.keys.right = false;
                });
                
                // è§¦æ‘¸æ§åˆ¶
                this.leftBtn.addEventListener('touchstart', () => this.keys.left = true);
                this.leftBtn.addEventListener('touchend', () => this.keys.left = false);
                this.rightBtn.addEventListener('touchstart', () => this.keys.right = true);
                this.rightBtn.addEventListener('touchend', () => this.keys.right = false);
                this.shootBtn.addEventListener('touchstart', () => this.shoot());
                
                // é¼ æ ‡æ§åˆ¶
                this.leftBtn.addEventListener('mousedown', () => this.keys.left = true);
                this.leftBtn.addEventListener('mouseup', () => this.keys.left = false);
                this.leftBtn.addEventListener('mouseleave', () => this.keys.left = false);
                this.rightBtn.addEventListener('mousedown', () => this.keys.right = true);
                this.rightBtn.addEventListener('mouseup', () => this.keys.right = false);
                this.rightBtn.addEventListener('mouseleave', () => this.keys.right = false);
                this.shootBtn.addEventListener('click', () => this.shoot());
                
                // çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', () => this.handleResize());
                this.handleResize();
            }
            
            handleResize() {
                const container = document.getElementById('planeGameContainer');
                const containerWidth = container.clientWidth;
                
                if (containerWidth < this.canvas.width) {
                    const scale = containerWidth / this.canvas.width;
                    this.canvas.style.width = `${containerWidth}px`;
                    this.canvas.style.height = `${this.canvas.height * scale}px`;
                } else {
                    this.canvas.style.width = `${this.canvas.width}px`;
                    this.canvas.style.height = `${this.canvas.height}px`;
                }
            }
            
            togglePause() {
                this.isPaused = !this.isPaused;
                
                if (!this.isPaused && this.isRunning) {
                    this.lastFrame = performance.now();
                    this.gameLoop();
                }
            }
            
            start() {
                this.isRunning = true;
                this.score = 0;
                this.bullets = [];
                this.enemies = [];
                this.player.x = this.canvas.width / 2 - 25;
                this.lastFrame = performance.now();
                this.gameLoop();
            }
            
            stop() {
                this.isRunning = false;
                
                // æ›´æ–°æœ€é«˜åˆ†
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('planeGameHighScore', this.highScore.toString());
                }
                
                // ç»˜åˆ¶æ¸¸æˆç»“æŸç•Œé¢
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = '30px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('æ¸¸æˆç»“æŸ', this.canvas.width/2, this.canvas.height/2 - 30);
                
                this.ctx.font = '20px Arial';
                this.ctx.fillText(`å¾—åˆ†: ${this.score}`, this.canvas.width/2, this.canvas.height/2 + 10);
                this.ctx.fillText(`æœ€é«˜åˆ†: ${this.highScore}`, this.canvas.width/2, this.canvas.height/2 + 40);
                
                this.ctx.font = '16px Arial';
                this.ctx.fillText('ç‚¹å‡»å±å¹•é‡æ–°å¼€å§‹', this.canvas.width/2, this.canvas.height/2 + 80);
                
                // æ·»åŠ é‡æ–°å¼€å§‹çš„ç‚¹å‡»äº‹ä»¶
                const restartHandler = () => {
                    this.canvas.removeEventListener('click', restartHandler);
                    this.start();
                };
                
                this.canvas.addEventListener('click', restartHandler);
            }
            
            shoot() {
                if (!this.isRunning || this.isPaused) return;
                
                this.bullets.push({
                    x: this.player.x + this.player.width / 2 - 2.5,
                    y: this.player.y,
                    width: 5,
                    height: 10,
                    speed: 7
                });
            }
            
            update(deltaTime) {
                if (this.isPaused) return;
                
                // æ›´æ–°é£æœºä½ç½®
                if (this.keys.left) {
                    this.player.x -= this.player.speed;
                }
                if (this.keys.right) {
                    this.player.x += this.player.speed;
                }
                
                // è¾¹ç•Œæ£€æŸ¥
                if (this.player.x < 0) {
                    this.player.x = 0;
                }
                if (this.player.x > this.canvas.width - this.player.width) {
                    this.player.x = this.canvas.width - this.player.width;
                }
                
                // æ›´æ–°å­å¼¹ä½ç½®
                this.bullets = this.bullets.filter(bullet => {
                    bullet.y -= bullet.speed;
                    return bullet.y > -bullet.height;
                });
                
                // ç”Ÿæˆæ•Œæœº
                if (Math.random() < this.enemySpawnRate) {
                    this.enemies.push({
                        x: Math.random() * (this.canvas.width - 40),
                        y: -40,
                        width: 40,
                        height: 40,
                        speed: this.enemySpeed + Math.random() * 2
                    });
                }
                
                // æ›´æ–°æ•Œæœºä½ç½®
                this.enemies = this.enemies.filter(enemy => {
                    enemy.y += enemy.speed;
                    
                    // æ£€æŸ¥ä¸å­å¼¹çš„ç¢°æ’
                    for (let i = 0; i < this.bullets.length; i++) {
                        const bullet = this.bullets[i];
                        if (this.checkCollision(bullet, enemy)) {
                            this.bullets.splice(i, 1);
                            this.score++;
                            return false;
                        }
                    }
                    
                    // æ£€æŸ¥ä¸ç©å®¶çš„ç¢°æ’
                    if (this.checkCollision(this.player, enemy)) {
                        this.stop();
                        return false;
                    }
                    
                    return enemy.y < this.canvas.height;
                });
                
                // éšç€åˆ†æ•°å¢åŠ éš¾åº¦
                this.enemySpawnRate = Math.min(0.05, 0.02 + this.score / 1000);
                this.enemySpeed = Math.min(6, 2 + this.score / 100);
            }
            
            checkCollision(obj1, obj2) {
                return obj1.x < obj2.x + obj2.width &&
                       obj1.x + obj1.width > obj2.x &&
                       obj1.y < obj2.y + obj2.height &&
                       obj1.y + obj1.height > obj2.y;
            }
            
            draw() {
                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶ç©å®¶é£æœº
                this.ctx.fillStyle = '#3366cc';
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x + this.player.width / 2, this.player.y);
                this.ctx.lineTo(this.player.x, this.player.y + this.player.height);
                this.ctx.lineTo(this.player.x + this.player.width, this.player.y + this.player.height);
                this.ctx.closePath();
                this.ctx.fill();
                
                // ç»˜åˆ¶é£æœºç»†èŠ‚
                this.ctx.fillStyle = '#6699ff';
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x + this.player.width / 2, this.player.y + 10);
                this.ctx.lineTo(this.player.x + 10, this.player.y + this.player.height - 5);
                this.ctx.lineTo(this.player.x + this.player.width - 10, this.player.y + this.player.height - 5);
                this.ctx.closePath();
                this.ctx.fill();
                
                // ç»˜åˆ¶å­å¼¹
                this.ctx.fillStyle = '#ff0000';
                this.bullets.forEach(bullet => {
                    this.ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                });
                
                // ç»˜åˆ¶æ•Œæœº
                this.enemies.forEach(enemy => {
                    // æ•Œæœºä¸»ä½“
                    this.ctx.fillStyle = '#33cc33';
                    this.ctx.beginPath();
                    this.ctx.moveTo(enemy.x + enemy.width / 2, enemy.y + enemy.height);
                    this.ctx.lineTo(enemy.x, enemy.y);
                    this.ctx.lineTo(enemy.x + enemy.width, enemy.y);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // æ•Œæœºç»†èŠ‚
                    this.ctx.fillStyle = '#66ff66';
                    this.ctx.beginPath();
                    this.ctx.moveTo(enemy.x + enemy.width / 2, enemy.y + enemy.height - 10);
                    this.ctx.lineTo(enemy.x + 10, enemy.y + 5);
                    this.ctx.lineTo(enemy.x + enemy.width - 10, enemy.y + 5);
                    this.ctx.closePath();
                    this.ctx.fill();
                });
                
                // ç»˜åˆ¶åˆ†æ•°
                this.ctx.fillStyle = '#000000';
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`åˆ†æ•°: ${this.score}`, 10, 25);
                
                // ç»˜åˆ¶æœ€é«˜åˆ†
                this.ctx.fillText(`æœ€é«˜åˆ†: ${this.highScore}`, 10, 50);
                
                // å¦‚æœæš‚åœï¼Œç»˜åˆ¶æš‚åœæç¤º
                if (this.isPaused) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '30px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('å·²æš‚åœ', this.canvas.width/2, this.canvas.height/2);
                    this.ctx.font = '16px Arial';
                    this.ctx.fillText('æŒ‰ P é”®ç»§ç»­', this.canvas.width/2, this.canvas.height/2 + 30);
                }
            }
            
            gameLoop(timestamp) {
                if (!this.isRunning) return;
                
                const now = timestamp || performance.now();
                const deltaTime = now - this.lastFrame;
                this.lastFrame = now;
                
                // é™åˆ¶æœ€å¤§æ—¶é—´æ­¥é•¿
                const maxDelta = 32; // çº¦30fpsçš„å¸§æ—¶é—´
                const clampedDelta = Math.min(deltaTime, maxDelta);
                
                this.update(clampedDelta);
                this.draw();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
        }
        
        // å¼¹ç æ¸¸æˆç±»
        class MarbleGame {
            constructor() {
                this.canvas = document.getElementById('marbleCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                
                this.gameActive = false;
                this.level = 1;
                this.maxLevel = 5;
                this.attempts = 0;
                
                this.marble = {
                    x: 100,
                    y: this.canvas.height - 100,
                    radius: 15,
                    color: '#ff4444',
                    velocity: { x: 0, y: 0 },
                    launched: false
                };
                
                this.hole = {
                    x: this.canvas.width - 100,
                    y: 100,
                    radius: 20,
                    color: '#333333'
                };
                
                this.obstacles = [];
                this.generateLevel(this.level);
                
                this.friction = 0.98;
                this.isDragging = false;
                this.dragStart = { x: 0, y: 0 };
                this.dragDistance = 0;
                this.message = null;
                this.messageTimeout = null;
                
                this.setupEventListeners();
            }
            
            resize() {
                this.canvas.width = Math.min(800, window.innerWidth - 40);
                this.canvas.height = Math.min(600, window.innerHeight - 150);
            }
            
            setupEventListeners() {
                // è§¦æ‘¸äº‹ä»¶
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startDrag({
                        clientX: e.touches[0].clientX,
                        clientY: e.touches[0].clientY
                    });
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.drag({
                        clientX: e.touches[0].clientX,
                        clientY: e.touches[0].clientY
                    });
                });
                
                this.canvas.addEventListener('touchend', () => {
                    this.launch();
                });
                
                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousedown', (e) => {
                    this.startDrag(e);
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    this.drag(e);
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.launch();
                });
                
                // çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', () => {
                    this.resize();
                    this.resetLevel();
                });
            }
            
            startDrag(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // åªæœ‰å½“å¼¹ç é™æ­¢æ—¶æ‰èƒ½æ‹–åŠ¨
                if (!this.marble.launched && this.distance(x, y, this.marble.x, this.marble.y) <= this.marble.radius) {
                    this.isDragging = true;
                    this.dragStart.x = x;
                    this.dragStart.y = y;
                    this.dragDistance = 0;
                }
            }
            
            drag(e) {
                if (!this.isDragging) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                this.dragStart.x = x;
                this.dragStart.y = y;
                
                // è®¡ç®—æ‹–åŠ¨è·ç¦»ï¼Œç”¨äºåŠ›é‡æ˜¾ç¤º
                const dx = this.marble.x - x;
                const dy = this.marble.y - y;
                this.dragDistance = Math.sqrt(dx*dx + dy*dy);
                
                // é™åˆ¶æœ€å¤§æ‹–åŠ¨è·ç¦»
                if (this.dragDistance > 150) {
                    const angle = Math.atan2(dy, dx);
                    this.dragStart.x = this.marble.x - Math.cos(angle) * 150;
                    this.dragStart.y = this.marble.y - Math.sin(angle) * 150;
                    this.dragDistance = 150;
                }
                
                // æŒç»­é‡ç»˜
                this.draw();
            }
            
            launch() {
                if (!this.isDragging) return;
                
                this.isDragging = false;
                this.attempts++;
                
                // è®¡ç®—é€Ÿåº¦ï¼ˆä¸æ‹–åŠ¨æ–¹å‘ç›¸åï¼‰
                const dx = this.marble.x - this.dragStart.x;
                const dy = this.marble.y - this.dragStart.y;
                const powerFactor = 0.1; // è°ƒæ•´å‘å°„åŠ›åº¦
                
                this.marble.velocity.x = dx * powerFactor;
                this.marble.velocity.y = dy * powerFactor;
                this.marble.launched = true;
                
                // å¼€å§‹æ¸¸æˆå¾ªç¯
                this.gameLoop();
            }
            
            update() {
                if (!this.marble.launched) return;
                
                // æ›´æ–°å¼¹ç ä½ç½®
                this.marble.x += this.marble.velocity.x;
                this.marble.y += this.marble.velocity.y;
                
                // è¾¹ç•Œç¢°æ’
                if (this.marble.x - this.marble.radius < 0) {
                    this.marble.x = this.marble.radius;
                    this.marble.velocity.x *= -0.8;
                } else if (this.marble.x + this.marble.radius > this.canvas.width) {
                    this.marble.x = this.canvas.width - this.marble.radius;
                    this.marble.velocity.x *= -0.8;
                }
                
                if (this.marble.y - this.marble.radius < 0) {
                    this.marble.y = this.marble.radius;
                    this.marble.velocity.y *= -0.8;
                } else if (this.marble.y + this.marble.radius > this.canvas.height) {
                    this.marble.y = this.canvas.height - this.marble.radius;
                    this.marble.velocity.y *= -0.8;
                }
                
                // éšœç¢ç‰©ç¢°æ’
                for (const obstacle of this.obstacles) {
                    if (this.checkObstacleCollision(this.marble, obstacle)) {
                        this.handleObstacleCollision(this.marble, obstacle);
                    }
                }
                
                // é€Ÿåº¦è¡°å‡
                this.marble.velocity.x *= this.friction;
                this.marble.velocity.y *= this.friction;
                
                // æ£€æµ‹èƒœåˆ© - å¼¹ç è¿›æ´
                const distToHole = this.distance(this.marble.x, this.marble.y, this.hole.x, this.hole.y);
                if (distToHole < this.hole.radius) {
                    this.levelComplete();
                    return;
                }
                
                // æ£€æµ‹åœæ­¢æ¡ä»¶
                if (Math.abs(this.marble.velocity.x) < 0.1 && Math.abs(this.marble.velocity.y) < 0.1) {
                    this.marble.launched = false;
                    this.marble.velocity.x = 0;
                    this.marble.velocity.y = 0;
                }
            }
            
            checkObstacleCollision(marble, obstacle) {
                // çŸ©å½¢éšœç¢ç‰©ç¢°æ’æ£€æµ‹
                let testX = marble.x;
                let testY = marble.y;
                
                if (marble.x < obstacle.x) testX = obstacle.x;
                else if (marble.x > obstacle.x + obstacle.width) testX = obstacle.x + obstacle.width;
                
                if (marble.y < obstacle.y) testY = obstacle.y;
                else if (marble.y > obstacle.y + obstacle.height) testY = obstacle.y + obstacle.height;
                
                const distance = this.distance(marble.x, marble.y, testX, testY);
                return distance <= marble.radius;
            }
            
            handleObstacleCollision(marble, obstacle) {
                // ç®€åŒ–çš„ç¢°æ’å“åº”
                // ç¡®å®šç¢°æ’ç‚¹å’Œç¢°æ’æ³•çº¿
                let closestX = Math.max(obstacle.x, Math.min(marble.x, obstacle.x + obstacle.width));
                let closestY = Math.max(obstacle.y, Math.min(marble.y, obstacle.y + obstacle.height));
                
                // ç¢°æ’æ¢å¤
                if (Math.abs(closestX - marble.x) < Math.abs(closestY - marble.y)) {
                    // æ°´å¹³ç¢°æ’
                    marble.velocity.x *= -0.8;
                    if (marble.x < closestX) {
                        marble.x = closestX - marble.radius;
                    } else {
                        marble.x = closestX + marble.radius;
                    }
                } else {
                    // å‚ç›´ç¢°æ’
                    marble.velocity.y *= -0.8;
                    if (marble.y < closestY) {
                        marble.y = closestY - marble.radius;
                    } else {
                        marble.y = closestY + marble.radius;
                    }
                }
            }
            
            levelComplete() {
                this.marble.launched = false;
                
                if (this.level === this.maxLevel) {
                    this.showMessage('æ­å–œï¼ä½ å®Œæˆäº†æ‰€æœ‰å…³å¡ï¼', 3000);
                    setTimeout(() => {
                        this.level = 1;
                        this.attempts = 0;
                        this.generateLevel(this.level);
                    }, 3000);
                } else {
                    this.level++;
                    this.showMessage(`å®Œæˆå…³å¡ ${this.level-1}ï¼`, 2000);
                    this.generateLevel(this.level);
                }
            }
            
            resetLevel() {
                // é‡ç½®å¼¹ç ä½ç½®å’Œå±æ€§
                this.marble.x = 100;
                this.marble.y = this.canvas.height - 100;
                this.marble.velocity.x = 0;
                this.marble.velocity.y = 0;
                this.marble.launched = false;
                
                // é‡æ–°ç”Ÿæˆå…³å¡
                this.generateLevel(this.level);
            }
            
            generateLevel(level) {
                // æ ¹æ®å…³å¡ç”Ÿæˆéšœç¢ç‰©å’Œç›®æ ‡
                this.obstacles = [];
                
                // æ ¹æ®å…³å¡è°ƒæ•´éš¾åº¦
                switch(level) {
                    case 1:
                        // ç®€å•å…³å¡ - ä¸€ä¸ªéšœç¢ç‰©
                        this.hole.x = this.canvas.width - 100;
                        this.hole.y = 100;
                        
                        this.obstacles.push({
                            x: this.canvas.width / 2 - 50,
                            y: this.canvas.height / 2 - 20,
                            width: 100,
                            height: 40,
                            color: '#888888'
                        });
                        break;
                        
                    case 2:
                        // ä¸¤ä¸ªéšœç¢ç‰©
                        this.hole.x = this.canvas.width - 100;
                        this.hole.y = this.canvas.height - 100;
                        
                        this.obstacles.push({
                            x: this.canvas.width / 3 - 30,
                            y: this.canvas.height / 3,
                            width: 60,
                            height: 100,
                            color: '#888888'
                        });
                        
                        this.obstacles.push({
                            x: 2 * this.canvas.width / 3 - 30,
                            y: 2 * this.canvas.height / 3 - 100,
                            width: 60, 
                            height: 100,
                            color: '#888888'
                        });
                        break;
                        
                    case 3:
                        // ä¸­ç­‰éš¾åº¦ - è¿·å®«å½¢çŠ¶
                        this.hole.x = this.canvas.width / 2;
                        this.hole.y = this.canvas.height / 2;
                        
                        // ä¸Šå¢™
                        this.obstacles.push({
                            x: 0,
                            y: this.canvas.height / 3 - 20,
                            width: 2 * this.canvas.width / 3,
                            height: 40,
                            color: '#888888'
                        });
                        
                        // ä¸‹å¢™
                        this.obstacles.push({
                            x: this.canvas.width / 3,
                            y: 2 * this.canvas.height / 3 - 20,
                            width: 2 * this.canvas.width / 3,
                            height: 40,
                            color: '#888888'
                        });
                        break;
                        
                    case 4:
                        // å›°éš¾ - å¤æ‚éšœç¢
                        this.hole.x = this.canvas.width - 80;
                        this.hole.y = this.canvas.height - 80;
                        
                        // åˆ›å»ºè¿·å®«æ ·å¼çš„éšœç¢
                        for (let i = 0; i < 3; i++) {
                            this.obstacles.push({
                                x: (i + 1) * this.canvas.width / 4 - 20,
                                y: 100,
                                width: 40,
                                height: this.canvas.height - 200,
                                color: '#888888'
                            });
                        }
                        
                        // æ¨ªå‘è¿æ¥
                        for (let i = 0; i < 2; i++) {
                            this.obstacles.push({
                                x: 100,
                                y: (i + 1) * this.canvas.height / 3,
                                width: this.canvas.width - 200,
                                height: 20,
                                color: '#888888'
                            });
                        }
                        break;
                        
                    case 5:
                        // æœ€ç»ˆå…³å¡ - éå¸¸å›°éš¾
                        this.hole.x = this.canvas.width / 2;
                        this.hole.y = this.canvas.height / 2;
                        
                        // åˆ›å»ºä¸€åœˆéšœç¢ï¼Œä¸­é—´å¼€å£
                        const thickness = 20;
                        const gapSize = 60;
                        const centerX = this.canvas.width / 2;
                        const centerY = this.canvas.height / 2;
                        const radius = Math.min(centerX, centerY) - 50;
                        
                        // ä¸Šéƒ¨
                        this.obstacles.push({
                            x: centerX - radius,
                            y: centerY - radius - thickness,
                            width: 2 * radius,
                            height: thickness,
                            color: '#888888'
                        });
                        
                        // ä¸‹éƒ¨
                        this.obstacles.push({
                            x: centerX - radius,
                            y: centerY + radius,
                            width: 2 * radius,
                            height: thickness,
                            color: '#888888'
                        });
                        
                        // å·¦éƒ¨ï¼ˆå¸¦å¼€å£ï¼‰
                        this.obstacles.push({
                            x: centerX - radius - thickness,
                            y: centerY - radius,
                            width: thickness,
                            height: (radius * 2 - gapSize) / 2,
                            color: '#888888'
                        });
                        
                        this.obstacles.push({
                            x: centerX - radius - thickness,
                            y: centerY + gapSize / 2,
                            width: thickness,
                            height: (radius * 2 - gapSize) / 2,
                            color: '#888888'
                        });
                        
                        // å³éƒ¨
                        this.obstacles.push({
                            x: centerX + radius,
                            y: centerY - radius,
                            width: thickness,
                            height: 2 * radius,
                            color: '#888888'
                        });
                        break;
                }
                
                // é‡ç½®å¼¹ç ä½ç½®
                this.marble.x = 100;
                this.marble.y = this.canvas.height - 100;
                this.marble.velocity.x = 0;
                this.marble.velocity.y = 0;
                this.marble.launched = false;
                
                // ç»˜åˆ¶åˆå§‹åœºæ™¯
                this.draw();
            }
            
            showMessage(text, duration = 2000) {
                this.message = {
                    text: text,
                    alpha: 1.0
                };
                
                clearTimeout(this.messageTimeout);
                this.messageTimeout = setTimeout(() => {
                    this.message = null;
                }, duration);
                
                // ç¡®ä¿æ¶ˆæ¯æ˜¾ç¤º
                this.draw();
                if (!this.marble.launched && !this.isDragging) {
                    this.gameLoop();
                }
            }
            
            drawMessage() {
                if (!this.message) return;
                
                this.ctx.save();
                this.ctx.globalAlpha = this.message.alpha;
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillStyle = 'white';
                this.ctx.font = '24px Arial';
                this.ctx.fillText(this.message.text, this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.restore();
                
                // æ¶ˆæ¯æ·¡å‡ºæ•ˆæœ
                if (this.message.alpha > 0) {
                    this.message.alpha -= 0.01;
                    if (this.message.alpha <= 0) {
                        this.message = null;
                    }
                }
            }
            
            distance(x1, y1, x2, y2) {
                return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            }
            
            draw() {
                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶èƒŒæ™¯
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#7cbf6d');
                gradient.addColorStop(1, '#5a9f5e');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶ç›®æ ‡æ´å£ï¼ˆå¸¦é˜´å½±ï¼‰
                this.ctx.beginPath();
                this.ctx.arc(this.hole.x, this.hole.y, this.hole.radius + 3, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                this.ctx.fill();
                
                this.ctx.beginPath();
                this.ctx.arc(this.hole.x, this.hole.y, this.hole.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = this.hole.color;
                this.ctx.fill();
                
                // ç»˜åˆ¶éšœç¢ç‰©
                this.obstacles.forEach(obstacle => {
                    // é˜´å½±
                    this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    this.ctx.fillRect(obstacle.x + 3, obstacle.y + 3, obstacle.width, obstacle.height);
                    
                    // éšœç¢ç‰©
                    this.ctx.fillStyle = obstacle.color;
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                });
                
                // ç»˜åˆ¶å¼¹ç 
                this.ctx.beginPath();
                this.ctx.arc(this.marble.x, this.marble.y, this.marble.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = this.marble.color;
                this.ctx.fill();
                
                // æ·»åŠ å¼¹ç é«˜å…‰æ•ˆæœ
                this.ctx.beginPath();
                this.ctx.arc(this.marble.x - this.marble.radius/3, this.marble.y - this.marble.radius/3, 
                             this.marble.radius/4, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(255,255,255,0.8)';
                this.ctx.fill();
                
                // ç»˜åˆ¶ç„å‡†çº¿
                if (this.isDragging) {
                    // è®¡ç®—åŠ›é‡æ¯”ä¾‹ï¼ˆ0-1ï¼‰
                    const powerRatio = Math.min(this.dragDistance / 150, 1);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.marble.x, this.marble.y);
                    this.ctx.lineTo(this.dragStart.x, this.dragStart.y);
                    this.ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    // ç»˜åˆ¶é¢„æµ‹è·¯å¾„ç‚¹
                    this.ctx.beginPath();
                    const dx = this.marble.x - this.dragStart.x;
                    const dy = this.marble.y - this.dragStart.y;
                    const power = 0.1; // ä¸ launch æ–¹æ³•ä¸­ç›¸åŒ
                    let predX = this.marble.x, predY = this.marble.y;
                    let predVelX = dx * power, predVelY = dy * power;
                    
                    for (let i = 0; i < 10; i++) {
                        predX += predVelX;
                        predY += predVelY;
                        predVelX *= this.friction;
                        predVelY *= this.friction;
                        
                        this.ctx.fillStyle = `rgba(255,255,255,${0.7 - i * 0.07})`;
                        this.ctx.beginPath();
                        this.ctx.arc(predX, predY, 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    // åŠ›é‡æ¡
                    const barWidth = 100;
                    const barHeight = 10;
                    const barX = this.canvas.width - barWidth - 20;
                    const barY = 20;
                    
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    const powerColor = this.getPowerColor(powerRatio);
                    this.ctx.fillStyle = powerColor;
                    this.ctx.fillRect(barX, barY, barWidth * powerRatio, barHeight);
                    
                    // åŠ›é‡æ–‡å­—
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('åŠ›é‡', barX - 30, barY + barHeight / 2 + 4);
                }
                
                // æ¸¸æˆä¿¡æ¯
                this.ctx.fillStyle = 'white';
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`å…³å¡: ${this.level}/${this.maxLevel}`, 20, 30);
                this.ctx.fillText(`å°è¯•æ¬¡æ•°: ${this.attempts}`, 20, 55);
                
                // æ¸¸æˆè¯´æ˜
                this.ctx.textAlign = 'left';
                this.ctx.font = '14px Arial';
                this.ctx.fillText('æ‹–åŠ¨å¼¹ç å¹¶é‡Šæ”¾æ¥å‘å°„', 20, this.canvas.height - 20);
                
                // ç»˜åˆ¶æ¶ˆæ¯
                this.drawMessage();
            }
            
            getPowerColor(ratio) {
                if (ratio < 0.3) return '#4CAF50'; // ç»¿è‰²
                if (ratio < 0.6) return '#FFC107'; // é»„è‰²
                return '#F44336'; // çº¢è‰²
            }
            
            gameLoop(timestamp) {
                if (!this.gameActive) return;
                
                const now = timestamp || performance.now();
                const deltaTime = now - (this.lastTime || now);
                this.lastTime = now;
                
                // æ›´æ–°æ¸¸æˆçŠ¶æ€
                this.update();
                
                // ç»˜åˆ¶åœºæ™¯
                this.draw();
                
                // å¦‚æœå¼¹ç åœ¨ç§»åŠ¨æˆ–æ­£åœ¨æ‹–åŠ¨ï¼Œç»§ç»­å¾ªç¯
                if (this.marble.launched || this.isDragging || this.message) {
                    requestAnimationFrame(this.gameLoop.bind(this));
                }
            }
            
            start() {
                this.gameActive = true;
                this.draw();
            }
            
            stop() {
                this.gameActive = false;
            }
        }

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            // è®¾ç½®å®˜æ–¹é’±åŒ…åœ°å€ï¼ˆæ›¿æ¢ä¸ºæ‚¨çš„å®é™…åœ°å€ï¼‰
            const walletAddress = 'YOUR_SOLANA_WALLET_ADDRESS';
            document.querySelector('.banner-wallet').textContent = walletAddress;
            
            // æ¨ªå¹…åˆ‡æ¢
            const banner = document.getElementById('officialBanner');
            const toggleBtn = document.getElementById('bannerToggle');
            
            toggleBtn.addEventListener('click', function() {
                banner.classList.toggle('banner-collapsed');
                toggleBtn.textContent = banner.classList.contains('banner-collapsed') ? 'â–¼' : 'â–²';
            });
            
            // åˆå§‹åŒ–é’±åŒ…ç®¡ç†
            WalletManager.initialize();
            
            // éšè—æ‰€æœ‰æ¸¸æˆå®¹å™¨
            document.getElementById('planeGameContainer').classList.add('hidden');
            document.getElementById('marbleGameContainer').classList.add('hidden');
            
            // æ¸¸æˆå®ä¾‹
            const planeGame = new PlaneGame();
            const marbleGame = new MarbleGame();
            
            // è®¾ç½®æ¸¸æˆé€‰æ‹©
            document.getElementById('planeGameOption').addEventListener('click', function() {
                document.getElementById('gameSelectorContainer').classList.add('hidden');
                document.getElementById('planeGameContainer').classList.remove('hidden');
                planeGame.start();
            });
            
            document.getElementById('marbleGameOption').addEventListener('click', function() {
                document.getElementById('gameSelectorContainer').classList.add('hidden');
                document.getElementById('marbleGameContainer').classList.remove('hidden');
                marbleGame.start();
            });
            
            // è¿”å›é€‰æ‹©æŒ‰é’®
            document.getElementById('backToSelector').addEventListener('click', function() {
                planeGame.stop();
                document.getElementById('planeGameContainer').classList.add('hidden');
                document.getElementById('gameSelectorContainer').classList.remove('hidden');
            });
            
            document.getElementById('backToSelectorMarble').addEventListener('click', function() {
                marbleGame.stop();
                document.getElementById('marbleGameContainer').classList.add('hidden');
                document.getElementById('gameSelectorContainer').classList.remove('hidden');
            });
            
            // é˜²æ­¢åœ¨è§¦æ‘¸è®¾å¤‡ä¸Šç¼©æ”¾
            document.addEventListener('touchmove', function(e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // é”™è¯¯å¤„ç†
            window.addEventListener('error', function(e) {
                console.error('å…¨å±€é”™è¯¯:', e.message);
                Helpers.showMessage('åº”ç”¨å‘ç”Ÿé”™è¯¯ï¼Œè¯·åˆ·æ–°é¡µé¢', 'error');
            });
        });
    </script>
</body>
</html>
